Questao 01  A expressão "p == &i" é verdadeira (1), enquanto "*p - *q" é igual a -2. Já "**&p" é igual a 3. Por fim, a expressão "3 - *p/(*q) + 7" resulta em 10.
p == &i;: Verdadeiro (1). *p - *q;: -2. **&p;: 3. 3 - *p/(*q) + 7;: 10.

Quetao 02 \

Questao 03 \ 
A expressão *q = &j é ilegal, pois tenta atribuir o endereço de j a um inteiro (*q). A expressão p = &&i é legal, pois obtém o endereço de i e atribui a p. A expressão i = (*&j) é ilegal, pois tenta desreferenciar o endereço de j. A expressão i = *j é legal, pois desreferencia o endereço de j e atribui a i. A expressão i = &&j é legal, pois obtém o valor de j e atribui a i. A expressão q = *p é ilegal, pois tenta atribuir um valor inteiro a um ponteiro. A expressão i = (*p)++ + *q é legal, pois incrementa o valor apontado por p e adiciona ao valor apontado por q, atribuindo a i.

Questao 05 \ contador/valor/valor/endereco/endereco i= vet[0] 1 1.1 *(f x 0) = 1.1 &vet[0] = 6644B60 (f + 0)=66F44B60 i= 1 vet[1] 2.2 *(f + 1) = 2.2 Svet[1] = 66F44B64 (f+

= 66F44B64 i = 2 vet[2] 3.3 *(f+2) =3:3 &vet[2] 6644B68 (f +
=66F44B68 i = 3 vet[3] = 4.4 *(f + 3) = 4.4 &vet[3] = 66F44B6C (f + 3)= 66F44B6C L = 4 vet[4] = 5.5 *(f + 4) = 5.5 &vet[4] 66F44B70 (f+
= 66F44B70
Questao 06 \  Para determinar qual expressão referencia o valor do terceiro elemento do vetor pulo[], devemos entender como a aritmética de ponteiros funciona em C. *(pulo + 2) e pulo + 2 são as expressões que referenciam o valor do terceiro elemento do vetor.



Questao 07 \  p aponta para o segundo elemento do array mat. p = mat; é uma expressão válida, assim como x = (*mat), que atribui o valor do primeiro elemento do array à variável x. Todas as expressões são corretas em C.

Questao 08 \ O programa imprime os elementos do array vet[] na saída. Ele declara e inicializa o array com os valores {4, 9, 13}. Um loop for é usado para percorrer o array e imprimir cada elemento usando a função printf(). O resultado seria: "4 9 13".


Questao 09 #include <stdio.h>

struct teste { int x; char nome[10]; // Deixei um tamanho arbitrário para o nome };

int main() { struct teste *s;

// Alocando memória para a struct
s = (struct teste *)malloc(sizeof(struct teste));

// Atribuindo valores aos membros da struct
s->x = 3;
strcpy(s->nome, "jose");

// Imprimindo os valores
printf("%d\n", s->x);
printf("%s\n", s->nome);

// Liberando a memória alocada
free(s);

return 0;
3
jose

Questao 10 \  A declaração int const *x = 3 resulta em um comportamento indefinido e warning de conversão de tipos. Incrementar *x em printf gera outro comportamento indefinido. O resultado do programa é imprevisível e precisa ser corrigido para funcionar corretamente.

Questao 11 \ Os endereços de memória para x+1, x+2 e x+3 são calculados com base no tamanho dos diferentes tipos de dado: char, int, float e double. O programa em C pode testar essas suposições.
